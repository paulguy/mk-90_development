    ; Some code and ideas taken from
    ; https://github.com/vladkorotnev/SMPEmu/blob/master/pdp/pdpfw.mac  and
    ; https://github.com/azya52/MK90/blob/master/TRex/trex.mac

	.ENABL AMA 	; Absolute addressing
	.ASECT		; Absolute section
    .RADIX 10

PLAYER_STARTX = SCREEN_MAP_W-5
PLAYER_STARTY = 4 ; from the right
DELAY_CYCLES = 4096

	.= 0		; Beginning of cartridge
    nop ; seems to be needed
    br loader

    .= 32 ; a bunch of interrupt vectors seem to be before here
scratch: ; this can be used as memory after things are loaded

    arg = scratch ; 162 bytes from here until the keyboard interrupt vector
    ; use as scratch space since the loader is not needed after initial bootup

	;	----------------------------------
	;	 OS Procedures and Vars
	;	----------------------------------

    PRINTATTRS = ^O34072
    PRINTNUM = ^O153360 ; arg. r3
    PRINT = ^O153414 ; arg. r1
    INITRAM = ^O153700
    INITTTY = ^O120536
    LCDINA = ^O164000
    LCDINB = ^O164002
    WAITCOMM = ^O174506
    SMPCMD = ^O164026
    SMPBAUD = ^O164022
    SMPCS = ^O164024
    SMPIO = ^O164020
    GETCH = ^O131120
    PUTCH = ^O116542

    INITIAL_SCREENMEM = 12288

    BOOTBLOCK_SIZE = 510 ; you'd think it'd be 512 but I guess not?

    SCREEN_WIDTH_B = 30
    SCREEN_WIDTH_W = SCREEN_WIDTH_B/2
    SCREEN_SIZE_B = 960
    SCREEN_SIZE_W = SCREEN_SIZE_B/2
    SCREEN_HEIGHT = 64
    SCREEN_WIDTH = 120

    ; add some scrollable region
    SCREEN_EXTRA_ROWS = 7
    SCREEN_EXTRA_MEM = SCREEN_EXTRA_ROWS*SCREEN_WIDTH_B
    SCREEN_PAGE = SCREEN_SIZE_B+SCREEN_EXTRA_MEM

    KEY_UP = 59
    KEY_DOWN = 63
    KEY_LEFT = 91
    KEY_W = 75
    KEY_X = 87
    KEY_7 = 71

; ########################################
; ##### Loader                       #####
; ########################################

loader:
    mov #16384, sp
	mov #^B1000100011000110, @#LCDINB	;26Hz

    mov #INITIAL_SCREENMEM+SCREEN_SIZE_B, r3
    mov #SCREEN_HEIGHT/4, r4
clear0:
    mov #SCREEN_WIDTH_W, r5
clear0a:
    bis #^B0101010101010101, -(r3)
    sob r5, clear0a
    sub #SCREEN_WIDTH_B, r3
    sob r4, clear0

    jsr pc, delay

    mov #INITIAL_SCREENMEM+SCREEN_SIZE_B-SCREEN_WIDTH_B, r3
    mov #SCREEN_HEIGHT/4, r4
clear1:
    mov #SCREEN_WIDTH_W, r5
clear1a:
    bis #^B1010101010101010, -(r3)
    sob r5, clear1a
    sub #SCREEN_WIDTH_B, r3
    sob r4, clear1

    jsr pc, delay

    br clear_cont
clear_return:

	;Loader copyed from Game of Life app of Piotr Piatek
    ;Which I copied again from the T-Rex game
	; specify the SMP address
	mtps #^O340		;disable interrupts
	bis	#8, r5		;writing to the SMP
	mov	r5,(r1)
	mov	#^O240, @#SMPCMD	;Write Address
	jsr	pc,(r2)
	movb #BOOTBLOCK_SIZE/256, @#SMPIO	;high address byte
	jsr	pc,(r2)
	movb #BOOTBLOCK_SIZE&255, @#SMPIO	;low address byte
	jsr	pc, (r2)
	tst	@#SMPCMD
	jsr	pc, (r2)
	; load data
	mov	#endOfProgram-BOOTBLOCK_SIZE, r4		;number of bytes
	mov	#BOOTBLOCK_SIZE, r3
	mov	#^O320, @#SMPCMD	;Read Postincrement
	jsr	pc, (r2)
	bic	#8, r5		;reading from the SMP
	mov	r5, (r1)
	jsr	pc, (r2)
nxtb:	
	movb @#SMPIO, (r3)+	;read data byte from the SMP to the RAM
	jsr	pc, (r2)
	sob	r4, nxtb		;next data byte
	tst	@#SMPCMD
	jsr	pc, (r2)
	; start the loaded program
	mov	#^O000, -(sp)	;user mode, interrupts enable
	mov	#start, -(sp)
	rti

delay:
    mov #DELAY_CYCLES, r3
delay_loop:
    sob r3, delay_loop

    rts pc

    .= 200 ; Location of KBCU IV
    .word	keyIntHandle, 0000

clear_cont:
    mov #INITIAL_SCREENMEM+SCREEN_SIZE_B, r3
    mov #SCREEN_HEIGHT/4, r4
clear2:
    mov #SCREEN_WIDTH_W, r5
clear2a:
    bis #^B1010101010101010, -(r3)
    sob r5, clear2a
    sub #SCREEN_WIDTH_B, r3
    sob r4, clear2

    jsr pc, delay

    mov #INITIAL_SCREENMEM+SCREEN_SIZE_B-SCREEN_WIDTH_B, r3
    mov #SCREEN_HEIGHT/4, r4
clear3:
    mov #SCREEN_WIDTH_W, r5
clear3a:
    bis #^B0101010101010101, -(r3)
    sob r5, clear3a
    sub #SCREEN_WIDTH_B, r3
    sob r4, clear3

    br clear_return

; ########################################
; ##### Utilities                    #####
; ########################################

keyIntHandle:
    mtps #^O340
    mov r0, -(sp)
    mov r1, -(sp)

    ;jsr pc, getRandom

    mov #SMPBAUD, r1
    mov #8, (r1)+ ;@#SMPBAUD
    mov r1, r0
    mov #^B11100010, (r1)+ ;@#SMPCS
    clr (r1);@#SMPCMD
waitGetKey:
    tstb (r0) ;@#SMPCS
    bpl waitGetKey
    mov (r1), @#inkey

    mov (sp)+, r1
    mov (sp)+, r0
    rti

getRandom:
    ; put random value in r1 (low bits for div go in r1)

    mov r0, -(sp)
    mov @#randomSeed, r1
    mov r1, r0
    ash #7, r0
    xor r0, r1
    mov r1, r0
    ash #-9, r0
    xor r0, r1
    mov r1, r0
    ash #8, r0
    xor r0, r1
    mov r1, @#randomSeed
    mov (sp)+, r0
    rts pc

drawNumber:
    dnum_val = arg
    dnum_x = bcopy_x
    dnum_y = bcopy_y

    mov @#dnum_val, r1
dnum_loop:
    ; save value
    mov r1, -(sp)
    ; get one's place (r1) and remaining (r0)
    clr r0
    div #10, r0
    mov r0, (sp)

    ; get relative pointer
    movb spr_num_ptrs(r1), r2
    ; turn it in to an absolute address
    add #spr_num_0, r2
    mov r2, @#bcopy_data
    movb spr_num_widths(r1), @#bcopy_h
    ; save current position and this height
    mov @#scrptr, -(sp)
    mov @#bcopy_h, -(sp)
    mov @#bcopy_y, -(sp)
    mov #screen0, @#scrptr
    jsr pc, drawbitmap
    mov #screen1, @#scrptr
    mov (sp), @#bcopy_y
    jsr pc, drawbitmap
    ; restore position and advance height
    mov (sp)+, @#bcopy_y
    add (sp)+, @#bcopy_y
    mov (sp)+, @#scrptr
    inc @#bcopy_y
 
    ; restore value
    mov (sp)+, r1
    bne dnum_loop

    rts pc

; ########################################
; ##### Bitmap Drawing               #####
; ########################################

drawBitmap:
    ; Draw a bitmap to the screen
    bcopy_data = arg ; pointer to data
    bcopy_h = arg+2 ; height in lines
    bcopy_x = arg+4 ; X position
    bcopy_y = arg+6 ; Y position
    bcopy_remaining_rows = scratch+8
    bcopy_remaining_columns = scratch+10
    bcopy_screen_pointer = scratch+12
    bcopy_temp = scratch+14
    bcopy_split_rows = scratch+16
    bcopy_orig_data = scratch+18
    bcopy_sp = scratch+20

    ; TODO: clip sprites that go offscreen
    ; Possible size optimization if needed: runtime modify the swab r5 lines
    ; with nop or swab r5 depending on whether top or bottom is being drawn
    ; to to save space on mostly repetitive code.

    ; figure out if the bitmap starts on the top or bottom of the screen split
    mov @#bcopy_y, r0
    cmp r0, #SCREEN_HEIGHT/2
    bge bitmapStartsBottom

; bitmap starts at top
    ; figure out if the sprite crosses the split and by how much
    add @#bcopy_h, r0
    sub #SCREEN_HEIGHT/2, r0
    bgt bitmapCrossesSplit

; bitmap is entirely on top
    mov @#bcopy_h, r1 ; get the full height of the sprite

    ; do bitmap copy for top of screen (low bits)
    jsr pc, copyBitmapTop

    rts pc

bitmapCrossesSplit:
    mov @#bcopy_h, r1
    sub r0, r1 ; r0 will have the number of lines over the split
    mov r0, @#bcopy_h ; save remaining since we don't need the old value, so r0 can be used
    mov r1, @#bcopy_split_rows
    mov @#bcopy_data, @#bcopy_orig_data

    ; do bitmap copy for top of screen
    jsr pc, copyBitmapTop

    add @#bcopy_split_rows, @#bcopy_orig_data
    mov @#bcopy_orig_data, @#bcopy_data
    mov #SCREEN_HEIGHT/2, @#bcopy_y ; continue from split

bitmapStartsBottom:
    mov @#bcopy_h, r1 ; get/restore remaining lines
    sub #SCREEN_HEIGHT/2, @#bcopy_y ; bottom half of the screen is high bytes of the same memory space

    ; do bitmap copy for bottom of screen (high bits)
    jsr pc, copyBitmapBottom

    rts pc

copyBitmapTop:
    ; r1 - height to copy
    
    ; save r1 because it'll be used with sob
    mov r1, @#bcopy_remaining_rows

    ; calculate pointer to first screen byte
    mov @#bcopy_y, r3
    mul #SCREEN_WIDTH_B, r3 ; r2 doesn't work?  use r3
    add @#scrptr, r3

    mtps #^B11100000 ; avoid SP being used
    mov sp, @#bcopy_sp
    mov r3, sp ; SP can't have the 1 bit set but the screen pointer shouldn't need it?

    mov @#bcopy_x, r2 ; get X offset and convert it to a byte offset by chopping off 3 bits
    ash #-3, r2
    asl r2 ; each 8 pixels on screen is 1 word apart
    add r2, sp ; add X offset to screen start pointer

    mov sp, @#bcopy_screen_pointer ; save the screen pointer too

    mov @#bcopy_data, r0 ; get first pointer to bitmap

    mov @#bcopy_x, r2 ; get how shifted right the value is by keeping the low 3 bits
    bic #^B1111111111111000, r2

    beq centerStripSimpleLoopTopStart ; take simple path if aligned

    neg r2 ; ash shifts right for negatives

    ; hold a frequent value in a free pointer
    mov #SCREEN_WIDTH_B, r5

leftStripLoopTop:
    movb (r0)+, r4 ; get bitmap byte
    bic #^B1111111100000000, r4 ; clear high bits so asr doesn't sign-extend
    ash r2, r4
    
    mov (sp), r3 ; get screen word

    bicb r4, r3 ; set bitmap bits in to screen word

    mov r3, (sp) ; write back to screen

    add r5, sp ; next screen row
    sob r1, leftStripLoopTop

    mov @#bcopy_data, r0 ; restore bitmap pointer in to r0

    add #2, @#bcopy_screen_pointer ; next screen column
    mov @#bcopy_screen_pointer, sp ; restore screen pointer

    mov @#bcopy_remaining_rows, r1 ; restore height

    add #8, r2 ; switch back to left shift

rightStripLoopTop:
    movb (r0)+, r4 ; get bitmap byte
    ash r2, r4 ; shift byte left, ash ignores high bits?
    bic #^B1111111100000000, r4 ; clear high bits

    mov (sp), r3 ; get screen word

    bicb r4, r3 ; set bitmap bits in to screen word

    mov r3, (sp) ; write back to screen

    add r5, sp ; update screen pointer
    sob r1, rightStripLoopTop

    mov @#bcopy_sp, sp
    mtps #^B00000000
    rts pc

centerStripSimpleLoopTopStart:
    mov #^B0000000011111111, r5
    mov #SCREEN_WIDTH_B, r2
centerStripSimpleLoopTop:
    movb (r0)+, r4 ; get bitmap byte

    mov (sp), r3 ; get screen word

    bicb r4, r3 ; write bitmap in to screen word

    mov r3, (sp) ; write word back to screen

    add r2, sp ; next screen row
    sob r1, centerStripSimpleLoopTop

    mov @#bcopy_sp, sp
    mtps #^B00000000
    rts pc

copyBitmapBottom:
    ; r1 - height to copy
    
    ; save r1 because it'll be used with sob
    mov r1, @#bcopy_remaining_rows

    ; calculate pointer to first screen byte
    mov @#bcopy_y, r3
    mul #SCREEN_WIDTH_B, r3 ; r2 doesn't work?  use r3
    add @#scrptr, r3

    mtps #^B11100000 ; avoid SP being used
    mov sp, @#bcopy_sp
    mov r3, sp ; SP can't have the 1 bit set but the screen pointer shouldn't need it?

    mov @#bcopy_x, r2 ; get X offset and convert it to a byte offset by chopping off 3 bits
    ash #-3, r2
    asl r2 ; each 8 pixels on screen is 1 word apart
    add r2, sp ; add X offset to screen start pointer

    mov sp, @#bcopy_screen_pointer ; save the screen pointer too

    mov @#bcopy_data, r0 ; get first pointer to bitmap

    mov @#bcopy_x, r2 ; get how shifted right the value is by keeping the low 3 bits
    bic #^B1111111111111000, r2

    beq centerStripSimpleLoopBottomStart ; take simple path if aligned

    neg r2 ; ash shifts right for negatives

    ; hold a frequent value in a free pointer
    mov #SCREEN_WIDTH_B, r5

leftStripLoopBottom:
    movb (r0)+, r4 ; get bitmap byte
    bic #^B1111111100000000, r4 ; clear high bits so asr doesn't sign-extend
    ash r2, r4
    
    mov (sp), r3 ; get screen word
    swab r3

    bicb r4, r3 ; set bitmap bits in to screen word

    swab r3
    mov r3, (sp) ; write back to screen

    add r5, sp ; next screen row
    sob r1, leftStripLoopBottom

    mov @#bcopy_data, r0 ; restore bitmap pointer in to r0

    add #2, @#bcopy_screen_pointer ; next screen column
    mov @#bcopy_screen_pointer, sp ; restore screen pointer

    mov @#bcopy_remaining_rows, r1 ; restore height

    add #8, r2 ; switch back to left shift

rightStripLoopBottom:
    movb (r0)+, r4 ; get bitmap byte
    ash r2, r4 ; shift byte left, ash ignores high bits?
    bic #^B1111111100000000, r4 ; clear high bits

    mov (sp), r3 ; get screen word
    swab r3

    bicb r4, r3 ; set bitmap bits in to screen word

    swab r3
    mov r3, (sp) ; write back to screen

    add r5, sp ; update screen pointer
    sob r1, rightStripLoopBottom

    mov @#bcopy_sp, sp
    mtps #^B00000000
    rts pc

centerStripSimpleLoopBottomStart:
    mov #^B0000000011111111, r5
    mov #SCREEN_WIDTH_B, r2
centerStripSimpleLoopBottom:
    movb (r0)+, r4 ; get bitmap byte

    mov (sp), r3 ; get screen word
    swab r3

    bicb r4, r3 ; write bitmap in to screen word

    swab r3
    mov r3, (sp) ; write word back to screen

    add r2, sp ; next screen row
    sob r1, centerStripSimpleLoopBottom

    mov @#bcopy_sp, sp
    mtps #^B00000000
    rts pc

; ########################################
; ##### Tilemap Drawing              #####
; ########################################

drawTilemap:
    tm_scrolly = arg ; Y scroll px, must be 0-7
    tm_yoffset = arg+2 ; Y offset in to buffer
    tm_screen_pointer = scratch+4
    tm_sp = scratch+6
    tm_xpos = scratch+8
    tm_ypos = scratch+10
    tm_row_ptrs = scratch+12 ; 9 words

    mov @#scrptr, r1
    add #SCREEN_SIZE_B-6, r1
    mov r1, @#tm_screen_pointer

    mtps #^B11100000 ; save SP
    mov sp, @#tm_sp

    mov #SCREEN_MAP_W-1, @#tm_xpos ; get the last tile on the screen row

    mov #8, r0 ; start at bottom row
    add @#tm_yoffset, r0 ; add offset
    mov #18, r2 ; + 2 because 0 is skipped
tmPopulatePtrs:
    bic #^B1111111111100000, r0 ; limit from 0-31
    movb tmWrapLookup(r0), r0 ; limit from 0-8
    mov r0, r1
    mul #SCREEN_MAP_W*2, r1 ; get the row
    add #SCREEN_MAP_W-1*2, r1 ; start at last column
    mov r1, tm_row_ptrs-2(r2) ; - 2 because 0 is skipped
    dec r0
    dec r2
    sob r2, tmPopulatePtrs

tmColumnLoop:
    mov @#tm_screen_pointer, sp

    mov #8, r4

    mov #6, @#tm_ypos
    tst @#tm_scrolly
    beq tmNoExtraRow
    add #2, @#tm_ypos
    mov @#tm_scrolly, r4
tmNoExtraRow:

tmTileLoop:
    mov @#tm_ypos, r2
    mov tm_row_ptrs(r2), r3
    mov screenMap(r3), r0 ; index to get pointer to tile data
    add r4, r0 ; start at last line

    add #8, r2
    mov tm_row_ptrs(r2), r3
    mov screenMap(r3), r1
    add r4, r1

    mov #SCREEN_WIDTH_B, r2
    ; r2 is free here, so use it.
    mov #^B1111111100000000, r3
    ; r3 is also free, so use it
tmRowLoop:
    movb -(r1), r5 ; move high byte in to low byte
    bic r3, r5 ; mask sign extension
    swab r5 ; swap high byte high
    bisb -(r0), r5 ; mask value in low
    mov r5, (sp) ; write to screen
    sub r2, sp ; update screen pointer
    sob r4, tmRowLoop

    mov #8, r4 ; reset tile row

    sub #2, @#tm_ypos
    bpl tmTileLoop

    mov #18, r0 ; 16 + 2 because 0 is skipped
tmMovePtrsLeft:
    sub #2, tm_row_ptrs-2(r0) ; - 2 because 0 is skipped
    dec r0
    sob r0, tmMovePtrsLeft

    sub #2, @#tm_screen_pointer ; next left column
    dec @#tm_xpos ; next column
    bpl tmColumnLoop

    mov @#tm_sp, sp ; restore SP
    mtps #^B00000000
    rts pc

tmWrapLookup:
    ; 32 bytes
    .byte 0, 1, 2, 3, 4, 5, 6, 7, 8, 0, 1, 2, 3, 4, 5, 6
    ; i don't know if it goes negative, but have some values for if it does?
    .byte 7, 8, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7, 8

; ########################################
; ##### Map Generation               #####
; ########################################

    gen_x = arg
    gen_y = arg+2
    gen_x_save = scratch+4
    gen_vals = scratch+6 ; 3 words
    gen_double = scratch+12 ; 3 words
    gen_dir = scratch+18 ; 0 = up, 1 = down
GEN_UP = 0
GEN_DOWN = 1

;TODO Fix floating water
gen_gather:
    ; r0 - not used
    ; r1 - pointer to probabilities
    ; r2 - not used (reserved)
    ; r3 - used (iterations counter)
    ; r4 - used (values pointer)
    ; r5 - used (doubles pointer)

    mov #gen_vals, r4
    mov #gen_double, r5
    mov #3, r3
gen_next_prob:
    tst (r4) ; check if disallowed already
    beq gen_done
    movb (r1), r0
    bne gen_no_Disallow ; test of not 0 (PMOD_DISALLOW)
    clr (r4) ; clear to 0 (disallowed)
    br gen_done ; no more to do
gen_no_Disallow:
    dec r0
    bne gen_no_AddOne ; test if not 1 (PMOD_ADDONE)
    inc (r4)
    br gen_done
gen_no_AddOne:
    dec r0
    bne gen_done ; test if not 2 (PMOD_DOUBLE)
    inc (r5)
gen_done: ; no need to check for PMOD_NOCHANGE, it'll just fall through
    tst (r4)+ ; increment to next word
    tst (r5)+
    inc r1
    sob r3, gen_next_prob

    rts pc

gen:
    gen_init_prob_air = 3
    gen_init_prob_land = 2
    gen_init_prob_water = 2

    ; initial values
    mov #gen_init_prob_air, @#gen_vals
    mov #gen_init_prob_land, @#gen_vals+2
    mov #gen_init_prob_water, @#gen_vals+4
    ; start with no shift
    clr @#gen_double
    clr @#gen_double+2
    clr @#gen_double+4

    mov @#gen_y, r3 ; y * width + x
    mul #SCREEN_MAP_W, r3
    add @#gen_x, r3
    add #collisionMap, r3
    mov r3, r2 ; save pointer

; get left neighbor
    mov #BLOCKTYPE_LAND, r1
    tst @#gen_x ; check if x is 0 so left neighbor would be nothing
    beq gen_leftNothing
    movb -1(r3), r1 ; neighbor to the left
gen_leftNothing:
    movb probability_ptrs(r1), r1
    ; left neighbor will generate probabilities for right neighbors
    add #probabilities_right, r1

    jsr pc, gen_gather

; get right neighbor
    mov r2, r3 ; restore pointer

    mov #BLOCKTYPE_LAND, r1
    ; check if x is the far right so neighbor would be nothing
    cmp @#gen_x, #SCREEN_MAP_W-1
    beq gen_rightNothing
    movb 1(r3), r1 ; neighbor to the right
gen_rightNothing:
    movb probability_ptrs(r1), r1
    ; right neighbor will generate probabilities for left neighbors
    add #probabilities_left, r1

    jsr pc, gen_gather

; get up neighbor
    mov r2, r3 ; restore pointer

    mov #BLOCKTYPE_NOTHING, r1
    tst @#gen_dir
    beq gen_upNothing ; if dir is 0 (up), new tiles will have nothing up neighbors
    tst @#gen_y ; check of y is > 0 to determine if next neighbor up doesn't need to wrap
    bne gen_up_noWrap
    ; if y is 0, r3 will just be the first row offset
    add #SCREEN_MAP_SIZE, r3
gen_up_noWrap:
    movb -SCREEN_MAP_W(r3), r1 ; neighbor up a row
gen_upNothing:
    movb probability_ptrs(r1), r1
    ; up neighbor will generate probabilities for down neighbors
    add #probabilities_down, r1

    jsr pc, gen_gather

; get down neighbor
    mov r2, r3 ; restore pointer

    mov #BLOCKTYPE_NOTHING, r1
    tst @#gen_dir
    bne gen_downNothing ; if dir is non-0 (down), new tiles will have nothing down neighbors
    ; check if y is the far bottom to determine if the pointer should wrap
    cmp @#gen_y, #SCREEN_MAP_H-1
    bne gen_down_noWrap
    ; if y is the map height, make it wrap back around to the top row
    sub #SCREEN_MAP_SIZE, r3
gen_down_noWrap:
    movb SCREEN_MAP_W(r3), r1 ; neighbor down a row
gen_downNothing:
    movb probability_ptrs(r1), r1
    ; down neighbor will generate probabilities for up neighbors
    add #probabilities_up, r1

    jsr pc, gen_gather

    ; do final multiplications
    mov @#gen_vals, r0
    ash @#gen_double, r0
    mov r0, @#gen_vals

    mov @#gen_vals+2, r0
    ash @#gen_double+2, r0
    mov r0, @#gen_vals+2

    mov @#gen_vals+4, r0
    ash @#gen_double+4, r0
    mov r0, @#gen_vals+4

    ; become a list of ranges
    add @#gen_vals, @#gen_vals+2
    add @#gen_vals+2, @#gen_vals+4

    ; get a value from 0 to max range-1
    jsr pc, getRandom
    clr r0
    div @#gen_vals+4, r0 ; remainder will be in r1

    tst @#gen_vals
    beq gen_no_air ; if 0, it has no range
    cmp r1, @#gen_vals
    bge gen_no_air ; if r1 >= value, it's outside of range
    movb #BLOCKTYPE_AIR, (r2) ; otherwise set the tile and end
    br gen_found_block
gen_no_air:
    cmp @#gen_vals, @#gen_vals+2
    beq gen_no_land ; if equal, it has no range
    cmp r1, @#gen_vals+2
    bge gen_no_land
    movb #BLOCKTYPE_LAND, (r2)
    br gen_found_block
gen_no_land:
    cmp @#gen_vals+2, @#gen_vals+4
    beq gen_no_water
    ; I could in theory just flal through and always set it to water, but I
    ; want the error state to be more obvious.
    cmp r1, @#gen_vals+4
    bge gen_no_water
    movb #BLOCKTYPE_WATER, (r2)
gen_no_water:
gen_found_block:

    rts pc

COIN_CHANCE = 20
AIR2_CHANCE = 5

collisionMapToTileMap:
    mov @#gen_y, r5
    mul #SCREEN_MAP_W, r5
    add #collisionMap, r5
    mov r5, r2

    mov @#gen_y, r5
    mul #SCREEN_MAP_W*2, r5
    add #screenMap, r5

    mov #SCREEN_MAP_W, r4
    movb (r2)+, r3 ; get type
    br cmap_no_top

cmap_next_tile:
    movb (r2)+, r3 ; get type
    cmp r3, #BLOCKTYPE_LAND
    bne cmap_no_land_top
    cmpb -2(r2), #BLOCKTYPE_LAND
    beq cmap_no_land_top
    mov #t_land_top, (r5)+
    br cmap_tile_done
cmap_no_land_top:
    cmp r3, #BLOCKTYPE_WATER
    bne cmap_no_water_top
    cmpb -2(r2), #BLOCKTYPE_AIR
    bne cmap_no_water_top
    mov #t_water_top, (r5)+
    br cmap_tile_done
cmap_no_water_top:
cmap_no_top:
    cmp r3, #BLOCKTYPE_AIR
    bne cmap_not_air2
    cmpb (r2), #BLOCKTYPE_AIR
    bne cmap_not_coin
    jsr pc, getRandom
    clr r0
    div #COIN_CHANCE, r0
    tst r1
    bne cmap_not_coin
    movb #BLOCKTYPE_COIN, -1(r2)
    mov #t_coin, (r5)+
    br cmap_tile_done
cmap_not_coin:
    jsr pc, getRandom
    clr r0
    div #AIR2_CHANCE, r0
    tst r1
    bne cmap_not_air2
    mov #t_air2, (r5)+
    br cmap_tile_done
cmap_not_air2:
    rol r3 ; bytes to words
    mov tile_ptrs(r3), r3
    mov r3, (r5)+ ; insert in to screen map
cmap_tile_done:
    sob r4, cmap_next_tile

    rts pc

genLeft:
    jsr pc, gen
    dec @#gen_x
    bpl genLeft

    rts pc

genRight:
    jsr pc, gen
    inc @#gen_x
    cmp @#gen_x, #SCREEN_MAP_W
    blt genRight

    rts pc

genStrip:
    jsr pc, getRandom
    clr r0 ; clear high bits/negative
    div #SCREEN_MAP_W-2, r0
    ; r1 has the remainder
    inc r1 ; make sure there's space above and below
    mov r1, @#gen_x
    mov r1, @#gen_x_save
    jsr pc, gen
    dec @#gen_x
    jsr pc, genLeft
    mov @#gen_x_save, @#gen_x
    inc @#gen_x
    jsr pc, genRight
    jsr pc, collisionMapToTileMap

    rts pc

genUp:
    mov #GEN_UP, @#gen_dir
genUp_loop:
    jsr pc, genStrip
    dec @#gen_y
    bpl genUp_loop

    rts pc

genDown:
    mov #GEN_DOWN, @#gen_dir
genDown_loop:
    jsr pc, genStrip
    inc @#gen_y
    cmp @#gen_y, #SCREEN_MAP_H
    blt genDown_loop

    rts pc

; ########################################
; ##### Screen Scrolling             #####
; ########################################

scrollScreen:
    scrollPX = arg
    ; don't check for 0 to assure reasonably consistent performance by
    ; always redrawing the screen

    mov @#scrollPX, -(sp) ; save because gen routines will clobber args

    mov @#bgY, r1
    mov r1, r0
    add (sp), r0

    ash #-8, r0 ; convert position to columns
    movb r0, r0 ; preserve sign (value should never be outside [-128, 127])
    ash #-8, r1
    movb r1, r1
    sub r1, r0 ; get number of new columns to generate
    beq scrollNone ; if 0, no map gen

    mov r1, @#gen_y

    mov #GEN_UP, @#gen_dir
    mov r0, -(sp) ; save number of new columns
    bmi scrollUp ; if negative, scroll up
    mov #GEN_DOWN, @#gen_dir

scrollDown:
    jsr pc, genStrip
    ; current column goes out of view first
    inc @#gen_y
    cmp @#gen_y, #SCREEN_MAP_H
    blt scrollDown_noWrap
    clr @#gen_y
scrollDown_noWrap:
    dec (sp)
    bne scrollDown

    br scrollDone

scrollUp:
    ; next column "up" is in view first
    dec @#gen_y
    bpl scrollUp_noWrap
    mov #SCREEN_MAP_H-1, @#gen_y
scrollUp_noWrap:
    jsr pc, genStrip
    inc (sp)
    bne scrollUp

scrollDone:
    tst (sp)+ ; restore SP
scrollNone:
    mov (sp)+, r1 ; get back scroll amount
    add @#bgY, r1 ; add current scroll amount
    sxt r0 ; make high bits negative if negative
    div #SCREEN_MAP_H_PX*POS_PER_PX, r0 ; divide to get modulo map size
    tst r1
    bpl scrollVarUpdate_noWrap
    add #SCREEN_MAP_H_PX*POS_PER_PX, r1 ; if negative, wrap it around
scrollVarUpdate_noWrap:
    mov r1, @#bgY ; store new value back

    ; draw the background
    ash #-5, r1
    mov r1, @#tm_scrolly
    bic #^B1111111111111000, @#tm_scrolly
    mov r1, r0
    ash #-3, r0
    bic #^B1111111111110000, r0
    mov r0, @#tm_yoffset
    jsr pc, drawTilemap

    rts pc

; ########################################
; ##### Player Movement              #####
; ########################################

PLAYER_ACCEL = 96
PLAYER_THRUST = 64
PLAYER_GRAV = 8
PLAYER_MAX_SPEED = 255 ; 1 tile length
PLAYER_MAX_X = SCREEN_MAP_W*8
updatePlayerMovement:
    tst @#inWater
    beq pmove_not_in_water
    movb @#playerXdir, r0
    mov r0, r1
    bic #^B0011111111111111, r0
    asr r1
    asr r1
    bis r0, r1
    movb r1, @#playerXDir
    movb @#playerYdir, r0
    mov r0, r1
    bic #^B0011111111111111, r0
    asr r1
    asr r1
    bis r0, r1
    movb r1, @#playerYDir
pmove_not_in_water:

    ; update player Y speed and clamp to 8 bit signed
    movb @#playerYDir, r2
    add @#playerYSpeed, r2
    cmp r2, #PLAYER_MAX_SPEED
    ble pmove_no_max_y_speed
    mov #PLAYER_MAX_SPEED, r2
    br pmove_no_min_y_speed
pmove_no_max_y_speed:
    cmp r2, #-PLAYER_MAX_SPEED
    bge pmove_no_min_y_speed
    mov #-PLAYER_MAX_SPEED, r2
pmove_no_min_y_speed:
    mov r2, @#scrollPX

    ; get player tilemap pos
    mov @#bgY, r1
    add r2, r1
    ; get center pos
    add #TILE_H*3+5*POS_PER_PX, r1
    ; wrap position to map height (in position units)
    cmp r1, #SCREEN_MAP_H_PX*POS_PER_PX
    blt pmove_screen_y_center_nowrap
    sub #SCREEN_MAP_H_PX*POS_PER_PX, r1
pmove_screen_y_center_nowrap:

    ; apply friction
    mov r2, r3 ; save sign
    bic #^B0001111111111111, r3
    mov r2, r4 ; get quarter speed
    ash #-3, r4
    bis r3, r4 ; restore sign
    sub r4, r2 ; subtract quarter speed
    mov r2, r3 ; get absolute value-ish
    sxt r4
    xor r4, r3
    ; check of least significant bits are too few to subtract
    bit #^B1111111111111000, r3
    bne pmove_no_smallest_y_speed
    clr r2
pmove_no_smallest_y_speed:
    mov r2, @#playerYSpeed ; store it back

    ; Do most of the same for the X axis, but simpler as there won't be any
    ; update player X speed
    movb @#playerXDir, r2
    add @#playerXSpeed, r2
    cmp r2, #PLAYER_MAX_SPEED
    ble pmove_no_max_x_speed
    mov #PLAYER_MAX_SPEED, r2
    br pmove_no_min_x_speed
pmove_no_max_x_speed:
    cmp r2, #-PLAYER_MAX_SPEED
    bge pmove_no_min_x_speed
    mov #-PLAYER_MAX_SPEED, r2
pmove_no_min_x_speed:

    ; update player position
    mov @#playerX, r0
    add r2, r0 ; make new value
    ; clamp to [0, PLAYER_MAX_X-sprite height]
    bpl pmove_no_min_x_pos
    clr r0
    ; make player "bonk"
    clr r2
    br pmove_no_max_x_pos
pmove_no_min_x_pos:
    cmp r0, #PLAYER_MAX_X-8*POS_PER_PX
    blt pmove_no_max_x_pos
    mov #PLAYER_MAX_X-8*POS_PER_PX, r0
    clr r2
pmove_no_max_x_pos:
    ; store back new speed
    mov r2, @#playerXSpeed

    ; if speed is negative, evaluate left
    bmi pmove_left

; otherwise evaluate right movement
    mov r1, r3 ; get new Y tile pos
    ash #-8, r3
    mul #SCREEN_MAP_W, r3 ; get row pointer
    mov r0, r2 ; get new X tile pos
    ash #-8, r2
    add r2, r3 ; add column
    inc r3 ; next column
    cmpb collisionMap(r3), #BLOCKTYPE_LAND
    beq pmove_right_bonk
    ; get bottom left corner coord
    mov r1, r3
    ; add player sprite height in position units
    add #plsprite_H-1*POS_PER_PX, r3
    ; wrap position to map height (in position units)
    cmp r3, #SCREEN_MAP_H_PX*POS_PER_PX
    blt pmove_right_screen_y_nowrap
    sub #SCREEN_MAP_H_PX*POS_PER_PX, r3
pmove_right_screen_y_nowrap:
    ; convert to tile location
    ash #-8, r3
    ; check if solid
    mul #SCREEN_MAP_W, r3 ; get row pointer
    add r2, r3 ; add column
    inc r3 ; next column
    cmpb collisionMap(r3), #BLOCKTYPE_LAND
    beq pmove_right_bonk

    br pmove_up_down

pmove_right_bonk:
    ; move playerX to tile boundary
    bic #^B11111111, r0
    ; no need to move over
    ; stop movement
    clr @#playerXSpeed

    br pmove_up_down

pmove_left:
    mov r1, r3 ; get new Y tile pos
    ash #-8, r3
    mul #SCREEN_MAP_W, r3 ; get row pointer
    mov r0, r2 ; get new X tile pos
    ash #-8, r2
    add r2, r3 ; add column
    cmpb collisionMap(r3), #BLOCKTYPE_LAND
    beq pmove_left_bonk
    ; get bottom left corner coord
    mov r1, r3
    ; add player sprite height in position units
    add #plsprite_H-1*POS_PER_PX, r3
    ; wrap position to map height (in position units)
    cmp r3, #SCREEN_MAP_H_PX*POS_PER_PX
    blt pmove_left_screen_y_nowrap
    sub #SCREEN_MAP_H_PX*POS_PER_PX, r3
pmove_left_screen_y_nowrap:
    ; convert to tile location
    ash #-8, r3
    ; check if solid
    mul #SCREEN_MAP_W, r3 ; get row pointer
    add r2, r3 ; add column
    cmpb collisionMap(r3), #BLOCKTYPE_LAND
    beq pmove_left_bonk

    br pmove_up_down

pmove_left_bonk:
    ; move playerX to tile boundary
    bic #^B11111111, r0
    ; move over 1 tile
    add #256, r0
    ; stop movement
    clr @#playerXSpeed

pmove_up_down:
    tst @#scrollPX ; check which direction is tried to be moved
    blt pmove_up

; handle down direction
    ; get bottom left corner coord
    mov r1, r3
    ; add player sprite height in position units
    add #plsprite_H-1*POS_PER_PX, r3
    ; wrap position to map height (in position units)
    cmp r3, #SCREEN_MAP_H_PX*POS_PER_PX
    blt pmove_down_screen_y_nowrap
    sub #SCREEN_MAP_H_PX*POS_PER_PX, r3
pmove_down_screen_y_nowrap:
    ; convert to tile location
    ash #-8, r3
    ; check if solid
    mul #SCREEN_MAP_W, r3 ; get row pointer
    add r2, r3 ; add column
    cmpb collisionMap(r3), #BLOCKTYPE_LAND
    beq pmove_down_bonk
    ; test new X alignment with tile edge, meaning only 1 test is needed
    ; (player is 1 tile high and in this case, occupies 1 tile)
    tstb r0
    beq pmove_done
    ; get next tile over
    inc r3
    ; check if solid
    cmpb collisionMap(r3), #BLOCKTYPE_LAND
    beq pmove_down_bonk

    br pmove_done

pmove_down_bonk:
    ; get old player Y
    mov @#bgY, r2
    ; get tile border position
    bic #^B11111111, r2
    ; get difference from old player Y and tile border
    sub @#bgY, r2
    add #plsprite_H/2*-POS_PER_PX+256, r2
    mov r2, @#scrollPX
    clr @#playerYSpeed

    br pmove_done

pmove_up:
    mov r1, r3 ; get new Y tile pos
    ash #-8, r3
    mul #SCREEN_MAP_W, r3 ; get row pointer
    mov r0, r2 ; get new X tile pos
    ash #-8, r2
    add r2, r3 ; add column
    cmpb collisionMap(r3), #BLOCKTYPE_LAND
    beq pmove_up_bonk
    ; test new X alignment with tile edge, meaning only 1 test is needed
    ; (player is 1 tile high and in this case, occupies 1 tile)
    tstb r0
    beq pmove_done
    ; get next tile over
    inc r3
    ; check if solid
    cmpb collisionMap(r3), #BLOCKTYPE_LAND
    beq pmove_up_bonk

    br pmove_done

pmove_up_bonk:
    ; get old player Y
    mov @#bgY, r2
    ; get tile border position
    bic #^B11111111, r2
    ; get difference from old player Y and tile border
    sub @#bgY, r2
    add #plsprite_H/2*POS_PER_PX, r2
    mov r2, @#scrollPX
    clr @#playerYSpeed

pmove_done:

; check if player is colliding with a coin or in water
    clr @#inWater

    mov r1, r3 ; get new Y tile pos
    ash #-8, r3
    mul #SCREEN_MAP_W, r3 ; get row pointer
    mov r0, r2 ; get new X tile pos
    ash #-8, r2
    add r2, r3 ; add column
    movb collisionMap(r3), r4
    cmp r4, #BLOCKTYPE_COIN
    bne pmove_not_coin_tl
    jsr pc, addCoin
    br pmove_not_water_tl
pmove_not_coin_tl:
    cmp r4, #BLOCKTYPE_WATER
    bne pmove_not_water_tl
    inc @#inWater
pmove_not_water_tl:
    inc r3
    movb collisionMap(r3), r4
    cmp r4, #BLOCKTYPE_COIN
    bne pmove_not_coin_tr
    jsr pc, addCoin
    br pmove_not_water_tr
pmove_not_coin_tl:
pmove_not_coin_tr:
    cmp r4, #BLOCKTYPE_WATER
    bne pmove_not_water_tr
    inc @#inWater
pmove_not_water_tr:
    ; get bottom left corner coord
    mov r1, r3
    ; add player sprite height in position units
    add #plsprite_H-1*POS_PER_PX, r3
    ; wrap position to map height (in position units)
    cmp r3, #SCREEN_MAP_H_PX*POS_PER_PX
    blt pmove_coin_check_y_nowrap
    sub #SCREEN_MAP_H_PX*POS_PER_PX, r3
pmove_coin_check_y_nowrap:
    ; convert to tile location
    ash #-8, r3
    ; check if solid
    mul #SCREEN_MAP_W, r3 ; get row pointer
    add r2, r3 ; add column
    movb collisionMap(r3), r4
    cmp r4, #BLOCKTYPE_COIN
    bne pmove_not_coin_bl
    jsr pc, addCoin
    br pmove_not_water_bl
pmove_not_coin_bl:
    cmp r4, #BLOCKTYPE_WATER
    bne pmove_not_water_bl
    inc @#inWater
pmove_not_water_bl:
    inc r3
    movb collisionMap(r3), r4
    cmp r4, #BLOCKTYPE_COIN
    bne pmove_not_coin_br
    jsr pc, addCoin
    br pmove_not_water_br
pmove_not_coin_br:
    cmp r4, #BLOCKTYPE_WATER
    bne pmove_not_water_br
    inc @#inWater
pmove_not_water_br:

    mov r0, @#playerX
    jsr pc, scrollScreen

    rts pc

addCoin:
    movb #BLOCKTYPE_AIR, collisionMap(r3)
    asl r3 ; bytes to words
    mov #t_air, screenMap(r3)
    asr r3
    inc @#coins


    ; save registers and variables which are important and would be overwritten
    mov @#scrollPX, -(sp)
    mov r0, -(sp)
    mov r1, -(sp)
    mov r3, -(sp)

    mov #SCREEN_HEIGHT/2, r0
    mov #SCREEN_SIZE_B-2, r1
counterClearLoop:
    mov #^B1111111111111111, screen0(r1)
    mov #^B1111111111111111, screen1(r1)
    sub #SCREEN_WIDTH_B, r1
    sob r0, counterClearLoop

    mov #TIME_PER_COIN, r0
    jsr pc, changeTime

    mov @#coins, @#dnum_val
    mov #8*14, @#dnum_x
    mov #1, dnum_y
    jsr pc, drawNumber

    ; restore values
    mov (sp)+, r3
    mov (sp)+, r1
    mov (sp)+, r0
    mov (sp)+, @#scrollPX

    rts pc

    ; 256 values per timer pixel
    MAX_TIME = SCREEN_HEIGHT*256
    TIME_PER_FRAME = 15
    TIME_PER_COIN = 200
changeTime:
    ; copy time in to r1 and r2, subtract time taken and put it back
    ; r2 is now the new value and r1 is the old value
    mov @#time, r1
    mov r1, r2
    add r0, r2
    bge cTime_no_end
    clr r2
    mov #GAME_MODE_ENDED, @#gameMode
cTime_no_end:

    cmp r2, #MAX_TIME
    blt cTime_no_max
    mov #MAX_TIME, r2
cTime_no_max:

    mov r2, @#time

    ; get the difference in units of 256
    ash #-8, r1
    ash #-8, r2

    cmp r2, r1
    blt cTime_take
    bgt cTime_give
    br cTime_done
cTime_give:
    mov r2, r1
cTime_take:

    neg r1
    add #SCREEN_HEIGHT, r1

    cmp r1, #SCREEN_HEIGHT/2
    blt cTime_top

; bottom screen
    sub #SCREEN_HEIGHT/2, r1
    mul #SCREEN_WIDTH_B, r1
    inc r1 ; get high byte
    comb screen0(r1)
    comb screen1(r1)

    br cTime_done

cTime_top:
    mul #SCREEN_WIDTH_B, r1
    comb screen0(r1)
    comb screen1(r1)

cTime_done:
    rts pc

copy_gfx:
    ; r0 - src pointer
    ; r1 - dst pointer
    ; r2 - columns
    ; r3 - stride
    mov r1, -(sp)
    mov #SCREEN_HEIGHT/2, r4
cGfx_loop:
    mov r2, r5
cGfx_line:
    mov (r0)+, (r1)+
    sob r5, cGfx_line
    add r3, (sp)
    mov (sp), r1
    sob r4, cGfx_loop

    tst (sp)+

    rts pc

; ########################################
; ##### Start                        #####
; ########################################

start:
    mov #12345, @#randomSeed

    ; reset state
    mov #PLAYER_STARTX*POS_PER_TILE, @#playerX
    clr @#playerXSpeed
    clr @#playerYSpeed
    mov #plspriteR, @#plsprite
    clr @#coins
    clr @#inWater
    mov #MAX_TIME, @#time
    movb #GAME_MODE_RUNNING, @#gameMode
    ; emulator controls
    ;movb #KEY_UP, @#rightButton
    ;movb #KEY_DOWN, @#leftButton
    ;movb #KEY_LEFT, @#jumpButton
    ; console controls
    movb #KEY_W, @#rightButton
    movb #KEY_X, @#leftButton
    movb #KEY_7, @#jumpButton

    mov #SCREEN_SIZE_B+2, r0
clearScreens:
    mov #-1, screen0-2(r0)
    mov #-1, screen1-2(r0)
    dec r0
    sob r0, clearScreens

    mov #SCREEN_SIZE_B-SCREEN_WIDTH_B, r0
draw_lines:
    mov #^B1111111011111110, screen0(r0)
    mov #^B0111111101111111, screen0+26(r0)
    mov #^B1111111011111110, screen1(r0)
    mov #^B0111111101111111, screen1+26(r0)
    sub #SCREEN_WIDTH_B*2, r0
    bpl draw_lines

    mov #screen0, @#scrptr
    mov #spr_time, @#bcopy_data
    mov #spr_time_H, @#bcopy_h
    clr @#bcopy_x
    mov #SCREEN_HEIGHT-spr_time_H-1, @#bcopy_y
    jsr pc, drawbitmap
    mov #screen1, @#scrptr
    mov #SCREEN_HEIGHT-spr_time_H-1, @#bcopy_y
    jsr pc, drawbitmap

    mov #screen0, @#scrptr
    mov #spr_coins, @#bcopy_data
    mov #spr_coins_H, @#bcopy_h
    mov #8*13, @#bcopy_x
    mov #SCREEN_HEIGHT-spr_coins_H-1, @#bcopy_y
    jsr pc, drawbitmap
    mov #screen1, @#scrptr
    mov #SCREEN_HEIGHT-spr_coins_H-1, @#bcopy_y
    jsr pc, drawbitmap

    mov @#coins, @#dnum_val
    mov #8*14, @#dnum_x
    mov #1, dnum_y
    jsr pc, drawNumber

; clear everything
    mov #screenMapEnd-screenMap+2, r0
clearScreenMap:
    mov #t_none, screenMap-2(r0)
    dec r0
    sob r0, clearScreenMap

    mov #collisionMapEnd-collisionMap+2, r0
clearCollisionMap:
    mov #0, collisionMap-2(r0)
    dec r0
    sob r0, clearCollisionMap

    ; starting platform
    movb #BLOCKTYPE_AIR, @#SCREEN_MAP_W*PLAYER_STARTY+PLAYER_STARTX+collisionMap
    movb #BLOCKTYPE_LAND, @#SCREEN_MAP_W*PLAYER_STARTY+PLAYER_STARTX+collisionMap+1

    mov #PLAYER_STARTY, @#gen_y

    mov #PLAYER_STARTX-1, @#gen_x
    jsr pc, genLeft

    mov #PLAYER_STARTX+2, @#gen_x
    jsr pc, genRight

    jsr pc, collisionMapToTileMap

    mov #PLAYER_STARTY-1, @#gen_y
    jsr pc, genUp

    mov #PLAYER_STARTY+1, @#gen_y
    jsr pc, genDown

    mov #4*POS_PER_PX, bgY ; start centered
    mov #screen0, @#LCDINA
    ;mov #screen0, @#scrptr ; for when flipping disabled

    mov #gfx_title, r0
    mov #screen0+2, r1
    mov #12, r2
    mov #SCREEN_WIDTH_B, r3
    jsr pc, copy_gfx

titleLoop:
    cmpb @#inkey, @#jumpButton
    bne titleLoop

loop:
    ;mov @#inkey, @#screen0
    cmpb @#gameMode, #GAME_MODE_RUNNING
    bne not_running
    
    movb #PLAYER_GRAV, @#playerXDir
    clrb @#playerYDir

    cmpb @#inkey, @#rightButton
    beq moveRight
    cmpb @#inkey, @#leftButton
    beq moveLeft
    cmpb @#inkey, @#jumpButton
    beq thrust
    br latMoveDone
moveRight:
    movb #-PLAYER_ACCEL, @#playerYDir
    mov #plspriteR, @#plsprite
    clr @#inkey
    br latMoveDone
moveLeft:
    movb #PLAYER_ACCEL, @#playerYDir
    mov #plspriteL, @#plsprite
    clr @#inkey
    br latMoveDone
thrust:
    movb #-PLAYER_THRUST, @#playerXDir
    clr @#inkey
latMoveDone:

    jsr pc, updatePlayerMovement

    mov #-TIME_PER_FRAME, r0
    jsr pc, changeTime

    br running_cont
not_running:
    ; just call scrollScreen since it's a pretty lightweight method that ends up
    ; drawing the screen anyway
    clr @#scrollPX
    jsr pc, scrollScreen

running_cont:

    mov @#plsprite, @#bcopy_data
    mov #plsprite_H, @#bcopy_h
    mov @#playerX, r0
    ; convert X position to pixel position
    ; 1 tile contains 256 possible positions on any axis
    ; 8 pixels per tile -> 32 positions per pixel, must trim 5 bits
    ash #-5, r0
    add #8, r0 ; offset for top status bar
    mov r0, @#bcopy_x
    ; center player sprite on screen
    mov #SCREEN_HEIGHT-plsprite_H/2, @#bcopy_y
    jsr pc, drawbitmap

    ;br noflipscr1 ; disable flipping
    cmp @#scrptr, #screen0
    beq flipscr1
    mov #screen1, @#LCDINA
	mov	#screen0, @#scrptr
    br noflipscr1
flipscr1:
    mov #screen0, @#LCDINA
	mov	#screen1, @#scrptr
noflipscr1:

    jsr pc, getRandom

    br loop

STRIP_W = 8
plspriteR:
    .byte ^B01100000
    .byte ^B10011111
    .byte ^B10011100
    .byte ^B11111100
    .byte ^B11111111
    .byte ^B01111000

plspriteL:
    .byte ^B01111000
    .byte ^B11111111
    .byte ^B11111100
    .byte ^B10011100
    .byte ^B10011111
    .byte ^B01100000
plsprite_H = 6

TILE_H = 8
SCREEN_TILES_W = SCREEN_WIDTH/STRIP_W
SCREEN_TILES_H = SCREEN_HEIGHT/TILE_H
t_none:
    .byte ^B00000001
    .byte ^B01000101
    .byte ^B00101001
    .byte ^B00010001
    .byte ^B00101001
    .byte ^B01000101
    .byte ^B00000001
    .byte ^B11111111

t_air:
    .byte ^B11111111
    .byte ^B11111111
    .byte ^B11111111
    .byte ^B11111111
    .byte ^B11111111
    .byte ^B11111111
    .byte ^B11111111
    .byte ^B11111111

t_air2:
    .byte ^B11111111
    .byte ^B11111111
    .byte ^B11011111
    .byte ^B11111111
    .byte ^B11111111
    .byte ^B11111011
    .byte ^B11110111
    .byte ^B11111111

t_land_top:
    .byte ^B01010110
    .byte ^B00101101
    .byte ^B00000100
    .byte ^B00001011
    .byte ^B00010100
    .byte ^B01000101
    .byte ^B00101010
    .byte ^B00010101

t_land:
    .byte ^B00101001
    .byte ^B10010110
    .byte ^B01101010
    .byte ^B10010101
    .byte ^B10001100
    .byte ^B01010010
    .byte ^B10100101
    .byte ^B01001010

t_water_top:
    .byte ^B10111111
    .byte ^B01011011
    .byte ^B01011011
    .byte ^B11011101
    .byte ^B01111101
    .byte ^B00101111
    .byte ^B00101101
    .byte ^B00111101

t_water:
    .byte ^B11111011
    .byte ^B11111011
    .byte ^B10111011
    .byte ^B10111111
    .byte ^B10111110
    .byte ^B11101110
    .byte ^B11101110
    .byte ^B11111111

t_coin:
    .byte ^B11100111
    .byte ^B10011001
    .byte ^B10111101
    .byte ^B01000010
    .byte ^B01000010
    .byte ^B10111101
    .byte ^B10011001
    .byte ^B11100111

tile_ptrs:
    .word t_none
    .word t_air
    .word t_land
    .word t_water

spr_time:
    .byte ^B01000100
    .byte ^B01010100
    .byte ^B01010100
    .byte ^B01111100
    .byte ^B00000000
    .byte ^B01111100
    .byte ^B00100000
    .byte ^B00010000
    .byte ^B00100000
    .byte ^B01111100
    .byte ^B00000000
    .byte ^B01111100
    .byte ^B00000000
    .byte ^B01000000
    .byte ^B01111100
    .byte ^B01000000
spr_time_H = 16

spr_coins:
    .byte ^B00101110
    .byte ^B00101010
    .byte ^B00101010
    .byte ^B00111010
    .byte ^B00000000
    .byte ^B00111110
    .byte ^B00001000
    .byte ^B00010000
    .byte ^B00111110
    .byte ^B00000000
    .byte ^B00111110
    .byte ^B00000000
    .byte ^B00111110
    .byte ^B00100010
    .byte ^B00100010
    .byte ^B00111110
    .byte ^B00000000
    .byte ^B00100010
    .byte ^B00100010
    .byte ^B00100010
    .byte ^B00111110
spr_coins_H = 21

spr_num_0:
    .byte ^B01111100
    .byte ^B10010010
    .byte ^B10100010
    .byte ^B01111100

spr_num_1:
    .byte ^B11111110

spr_num_2:
    .byte ^B01100010
    .byte ^B10010010
    .byte ^B10001010
    .byte ^B01000110

spr_num_3:
    .byte ^B01101100
    .byte ^B10010010
    .byte ^B10010010
    .byte ^B01000100

spr_num_4:
    .byte ^B11111110
    .byte ^B00001000
    .byte ^B01101000
    .byte ^B00011000

spr_num_5:
    .byte ^B10001100
    .byte ^B10010010
    .byte ^B10010010
    .byte ^B11110100

spr_num_6:
    .byte ^B01001100
    .byte ^B10010010
    .byte ^B10010010
    .byte ^B01111100

spr_num_7:
    .byte ^B11110000
    .byte ^B10001110
    .byte ^B10000000
    .byte ^B10000000

spr_num_8:
    .byte ^B01101100
    .byte ^B10010010
    .byte ^B10010010
    .byte ^B01101100

spr_num_9:
    .byte ^B01111100
    .byte ^B10010010
    .byte ^B10010010
    .byte ^B01100100

spr_num_ptrs:
    .byte 0
    .byte spr_num_1-spr_num_0
    .byte spr_num_2-spr_num_0
    .byte spr_num_3-spr_num_0
    .byte spr_num_4-spr_num_0
    .byte spr_num_5-spr_num_0
    .byte spr_num_6-spr_num_0
    .byte spr_num_7-spr_num_0
    .byte spr_num_8-spr_num_0
    .byte spr_num_9-spr_num_0

spr_num_widths:
    .byte spr_num_1-spr_num_0
    .byte spr_num_2-spr_num_1
    .byte spr_num_3-spr_num_2
    .byte spr_num_4-spr_num_3
    .byte spr_num_5-spr_num_4
    .byte spr_num_6-spr_num_5
    .byte spr_num_7-spr_num_6
    .byte spr_num_8-spr_num_7
    .byte spr_num_9-spr_num_8
    .byte spr_num_ptrs-spr_num_9

PMOD_DISALLOW = 0
PMOD_ADDONE = 1
PMOD_DOUBLE = 2
PMOD_NOCHANGE = 3
    ; each is in west, east, south, north order
probabilities_start:
probabilities_left:
    ; probability mod for air, land, water
    .byte PMOD_ADDONE, PMOD_ADDONE, PMOD_NOCHANGE
probabilities_right:
    .byte PMOD_ADDONE, PMOD_ADDONE, PMOD_NOCHANGE
probabilities_down:
    .byte PMOD_ADDONE, PMOD_ADDONE, PMOD_NOCHANGE
probabilities_up:
    .byte PMOD_ADDONE, PMOD_ADDONE, PMOD_NOCHANGE
probabilities_air:
    .byte PMOD_DOUBLE, PMOD_NOCHANGE, PMOD_DISALLOW
    .byte PMOD_DOUBLE, PMOD_ADDONE, PMOD_ADDONE
    .byte PMOD_DOUBLE, PMOD_NOCHANGE, PMOD_DISALLOW
    .byte PMOD_DOUBLE, PMOD_NOCHANGE, PMOD_DISALLOW
probabilities_land:
    .byte PMOD_DOUBLE, PMOD_NOCHANGE, PMOD_NOCHANGE
    .byte PMOD_ADDONE, PMOD_DOUBLE, PMOD_NOCHANGE
    .byte PMOD_ADDONE, PMOD_DOUBLE, PMOD_ADDONE
    .byte PMOD_ADDONE, PMOD_DOUBLE, PMOD_ADDONE
probabilities_water:
    .byte PMOD_NOCHANGE, PMOD_NOCHANGE, PMOD_DOUBLE
    .byte PMOD_DISALLOW, PMOD_NOCHANGE, PMOD_DOUBLE
    .byte PMOD_DISALLOW, PMOD_NOCHANGE, PMOD_DOUBLE
    .byte PMOD_DISALLOW, PMOD_NOCHANGE, PMOD_DOUBLE

probability_ptrs:
    .byte 0
    .byte probabilities_air-probabilities_start
    .byte probabilities_land-probabilities_start
    .byte probabilities_water-probabilities_start

gfx_title:
	.word ^D65535, ^D61951, ^D34784, ^D38783, ^D56412, ^D50372
    .word ^D256, ^D54016, ^D53521, ^D40349, ^D33791, ^D65535
    .word ^D65535, ^D63999, ^D36833, ^D34095, ^D56540, ^D50372
    .word ^D0, ^D52992, ^D53521, ^D40349, ^D49151, ^D48127
    .word ^D65535, ^D65535, ^D4070, ^D276, ^D23772, ^D50372
    .word ^D256, ^D54020, ^D53521, ^D40349, ^D49151, ^D33719
    .word ^D65535, ^D65535, ^D1760, ^D255, ^D23772, ^D50372
    .word ^D0, ^D56576, ^D53521, ^D40349, ^D65535, ^D48043
    .word ^D65535, ^D65535, ^D240, ^D7291, ^D56540, ^D50372
    .word ^D33, ^D32767, ^D53713, ^D40349, ^D47103, ^D65451
    .word ^D65535, ^D65535, ^D33011, ^D8094, ^D56540, ^D50372
    .word ^D97, ^D193, ^D4561, ^D40349, ^D44031, ^D49115
    .word ^D65535, ^D65535, ^D57584, ^D16207, ^D56540, ^D50372
    .word ^D253, ^D7421, ^D4561, ^D40349, ^D44031, ^D45055
    .word ^D65535, ^D65535, ^D55520, ^D12155, ^D56540, ^D50373
    .word ^D253, ^D2299, ^D4561, ^D40349, ^D56319, ^D44959
    .word ^D16383, ^D65535, ^D50917, ^D2975, ^D56412, ^D50372
    .word ^D252, ^D2299, ^D4561, ^D40349, ^D65535, ^D33763
    .word ^D49663, ^D65535, ^D57825, ^D33653, ^D56540, ^D50372
    .word ^D97, ^D247, ^D4561, ^D40349, ^D511, ^D65439
    .word ^D65279, ^D65535, ^D63970, ^D59143, ^D56540, ^D50372
    .word ^D288, ^D65527, ^D53713, ^D40349, ^D8703, ^D48127
    .word ^D65535, ^D32767, ^D65506, ^D65470, ^D56540, ^D50372
    .word ^D256, ^D49535, ^D53713, ^D40349, ^D20991, ^D43963
    .word ^D32767, ^D49151, ^D65505, ^D32713, ^D56540, ^D50372
    .word ^D256, ^D63232, ^D53521, ^D40349, ^D20991, ^D43947
    .word ^D63231, ^D57343, ^D65506, ^D48939, ^D56412, ^D50372
    .word ^D0, ^D63232, ^D53521, ^D40349, ^D32255, ^D33707
    .word ^D65535, ^D49151, ^D65520, ^D65407, ^D56540, ^D50372
    .word ^D256, ^D63260, ^D53521, ^D40349, ^D447, ^D65411
    .word ^D65535, ^D32767, ^D65520, ^D61312, ^D56412, ^D50372
    .word ^D0, ^D63256, ^D53521, ^D40349, ^D32191, ^D51199
    .word ^D57087, ^D65535, ^D65528, ^D63295, ^D56540, ^D50372
    .word ^D0, ^D32540, ^D53521, ^D40349, ^D8579, ^D48059
    .word ^D65020, ^D65311, ^D65535, ^D65535, ^D56540, ^D50372
    .word ^D32, ^D0, ^D4369, ^D40349, ^D4543, ^D48087
    .word ^D62960, ^D65287, ^D65535, ^D65535, ^D56540, ^D50372
    .word ^D113, ^D4351, ^D4561, ^D40349, ^D8639, ^D33775
    .word ^D64993, ^D65475, ^D65535, ^D65023, ^D56540, ^D50372
    .word ^D249, ^D7389, ^D4561, ^D40349, ^D32255, ^D65411
    .word ^D65223, ^D65521, ^D65535, ^D65535, ^D56540, ^D50373
    .word ^D253, ^D7381, ^D4561, ^D40349, ^D467, ^D48127
    .word ^D63439, ^D32761, ^D65535, ^D65535, ^D23772, ^D50372
    .word ^D28784, ^D213, ^D4561, ^D40349, ^D32175, ^D44031
    .word ^D49039, ^D49144, ^D65535, ^D65535, ^D56540, ^D50372
    .word ^D29041, ^D65493, ^D53713, ^D40349, ^D1455, ^D44031
    .word ^D65432, ^D57100, ^D65535, ^D65535, ^D56540, ^D50372
    .word ^D29040, ^D56811, ^D53713, ^D40349, ^D1411, ^D33723
    .word ^D65168, ^D57092, ^D65535, ^D65535, ^D56540, ^D50372
    .word ^D29040, ^D60287, ^D53713, ^D40349, ^D31231, ^D65451
    .word ^D65432, ^D61196, ^D65487, ^D65535, ^D56540, ^D50372
    .word ^D28784, ^D63232, ^D53521, ^D40349, ^D451, ^D427
    .word ^D46991, ^D57336, ^D65479, ^D65535, ^D56540, ^D50628
    .word ^D64768, ^D60180, ^D53521, ^D40349, ^D31151, ^D11651
    .word ^D65487, ^D49145, ^D65519, ^D65535, ^D56540, ^D50372
    .word ^D63488, ^D56600, ^D53521, ^D40349, ^D17839, ^D20991
    .word ^D65479, ^D32753, ^D65534, ^D65407, ^D56540, ^D50372
    .word ^D28672, ^D32532, ^D53521, ^D40349, ^D1475, ^D20867
    .word ^D65249, ^D65475, ^D65529, ^D65471, ^D56540, ^D50372
    .word ^D8192, ^D0, ^D4369, ^D40349, ^D2559, ^D32239
    .word ^D61168, ^D65287, ^D65507, ^D65503, ^D56540, ^D50372
    .word ^D1, ^D255, ^D4561, ^D40349, ^D447, ^D479
    .word ^D65532, ^D32541, ^D65479, ^D65503, ^D56540, ^D50372
    .word ^D1, ^D221, ^D4561, ^D40349, ^D65471, ^D65411

.EVEN

endOfProgram: ; must not go beyond 10KB
; This area will be memory values.
; even if these get cut off by the 10KB memory card limit, they'll be initialized elsewhere anyway

; screen width / tile width, 120 / 8 + 1 = 16
; screen height / tile height, 64 / 8 + 1 = 9
SCREEN_MAP_W = 12
SCREEN_MAP_H = SCREEN_TILES_H+1
SCREEN_MAP_SIZE = SCREEN_MAP_W*SCREEN_MAP_H
SCREEN_MAP_H_PX = SCREEN_MAP_H*TILE_H
screenMap:
    .word 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    .word 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    .word 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    .word 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    .word 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    .word 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    .word 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    .word 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    .word 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
screenMapEnd:

BLOCKTYPE_NOTHING = 0
BLOCKTYPE_AIR = 1
BLOCKTYPE_LAND = 2
BLOCKTYPE_WATER = 3
BLOCKTYPE_COIN = 4
collisionMap:
    .byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    .byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    .byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    .byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    .byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    .byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    .byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    .byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    .byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
collisionMapEnd:

; 2 screen pages
screenTop0:
    .blkb SCREEN_EXTRA_MEM
screen0:
    .blkb SCREEN_SIZE_B
screenTop1:
    .blkb SCREEN_EXTRA_MEM
screen1:
    .blkb SCREEN_SIZE_B
scrptr:
    .word 0
inkey:
    .word 0
randomSeed:
    .word 0

; state variables
bgY:
    .word 0

POS_PER_TILE = 256 ; low bit for sub-tile pos
POS_PER_PX = POS_PER_TILE/TILE_H
playerX:
    .word 0
playerXDir:
    .byte 0
playerYDir:
    .byte 0
playerXSpeed:
    .word 0
playerYSpeed:
    .word 0
plsprite:
    .word 0
coins:
    .word 0
inWater:
    .word 0
time:
    .word 0
GAME_MODE_RUNNING = 1
GAME_MODE_ENDED = 0
gameMode:
    .byte 0
rightButton:
    .byte 0
leftButton:
    .byte 0
jumpButton:
    .byte 0

endOfRAM: ; must not go beyond 16KB

; no idea if these work, they don't seem to print anything at least, but i'm probably misunderstanding something.
.IF GT endOfProgram-10240
.ERROR endOfProgram ; Program and data size extends beyond the 10KB SMP ROM size
.IFF
.PRINT endOfProgram ; Program and Data Size
.ENDC

.IF GT endOfRAM-16384
.ERROR endOfRAM ; Program, data and memory space extends beyond the 16KB RAM space
.IFF
.PRINT endOfRAM ; Program, Data and Memory Size
.ENDC
